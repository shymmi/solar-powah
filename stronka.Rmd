---
title: "Optymalizacja elektrowni s³onecznej"
author: "Szymon Kasperski"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document: 
    toc: true
---

```{r setup, echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE}
knitr::opts_chunk$set(echo = TRUE)
#kod wyliczaj¹cy wykorzystane biblioteki
devtools::install_github("rstudio/EDAWR")
devtools::install_github("rstudio/dplyr")
devtools::install_github("rstudio/ggplot2")
devtools::install_github("ropensci/plotly")
devtools::install_github("taiyun/corrplot")
#wiecej bibliotek
```

```{r libraries, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
set.seed(23) #kod zapewniaj¹cy powtarzalnoœæ wyników
library(EDAWR)
library(ggplot2)
library(dplyr)
library(plotly)
library(corrplot)
#wiecej bibliotek
```

```{r import, cache=FALSE, include=FALSE}
solar_data <- read.csv("elektrownie.csv", row.names=1)
solar_data$data <- as.POSIXct(solar_data$data, format="%m/%d/%Y %H:%M")
```

## Krótkie podsumowanie - elevator speach
```{r echo=FALSE}
#podsumowanie obserwacji - tekst dla "Obamy"
```

## Rozmiar zbioru i podstawowe statystyki.

Dane zawieraj¹ '`r nrow(solar_data)`' obserwacji po '`r length(solar_data)`' atrybutów ka¿da. Poni¿ej znajduje siê podsumowanie wartoœci dla ka¿dego atrybutu.

### Dane czujnika
```{r sensor_data}
lapply(solar_data[, c('idsito', 'idmodel', 'idbrand', 'ageinmonths')], summary)
```
Pierwsze 3 zawieraj¹ informacje o identyfikatorze, modelu i marce czujnika.
W tym zbiorze mo¿na wyró¿niæ `r length(table(solar_data$idsito))` czujników, o `r length(table(solar_data$idmodel))` ró¿nych modelach, wyprodukowanych przez `r length(table(solar_data$idbrand))` ró¿nych producentów. Wszystkie wartoœci tych atrybutów zosta³y znormalizowane i zawieraj¹ siê w przedziale <0:1>. Czwarty atrybut (tak samo znormalizowany) opisuje wiek danego czujnika, jego wartoœæ jest sta³a dla ka¿dego idsito.

### Czas
```{r time_data}
lapply(solar_data[, c('anno', 'day', 'ora', 'data')], summary)
```
Powy¿sze atrybuty opisuj¹ czas dokonania pomiaru. Anno okreœla rok dokonania pomiaru i przyjmuje dwie wartoœci; 2012 i 2013. Day, jak sama nazwa wskazuje, okreœla dzieñ dokonania pomiaru. Przyjmuje `r length(table(solar_data$day))` ró¿nych wartoœci, co sugeruje, ¿e odzwierciedla kalendarzowy dzieñ dla danego roku. Atrybut ora przyjmuje `r length(table(solar_data$ora))` ró¿nych wartoœci, co sugeruje, ¿e pomiary by³y dokonywane w 19 ró¿nych godzinach dla ró¿nych dób. Po przylrzeniu siê wartoœciom atrybutu *data* mo¿na zauwa¿yæ, ¿e pomiary dla ka¿dego dnia by³y przeprowadzane w godzinach 2:00 - 20:00, co godzinê. Ostatni atrybut zawiera informacje zawarte w trzech poprzednich; rok, dzieñ, godzinê dokonania pomiaru w bardziej przystêpnej postaci - jako (nieznormalizowany) ci¹g znaków.

### Po³o¿enie
```{r loc_data}
lapply(solar_data[, c('lat', 'lon')], summary)
```
Powy¿sze atrybuty opisuj¹ fizyczne po³o¿enie czujników. Wartoœci atrybutu lat opisuj¹ szerokoœæ geograficzn¹, a lon d³ugoœæ. Zakres wartoœci atrybutu lat to <`r min(solar_data[, 'lat'])`:`r max(solar_data[, 'lat'])`>, co sugeruje, ¿e czujniki po³o¿one by³y na podobnej szerokoœci geograficznej.

### Warunki atmosferyczne
```{r atmo_data}
lapply(solar_data[, c('temperatura_ambiente', 'irradiamento', 'pressure', 'windspeed', 'humidity', 'dewpoint', 'windbearing', 'cloudcover', 'irr_pvgis_mod', 'icon')], summary)
```
Powy¿sze atrybuty opisuj¹ aktualn¹ pogodê "mierzon¹" podczas zapisu danych przez czujnik. Opisuj¹ odpowiednio: temperaturê powietrza, stopieñ nas³onecznienia, ciœnienie atmosferyczne, prêdkoœæ wiatru, wilgotnoœæ, temperaturê punktu rosy, zachmurzenie i ponownie stopieñ nas³onecznienia, tym razem generowany przez pogodowe API (Photovoltaic Geographical Information System). Ostatnia zmienna (icon) przyjmuje tylko 7 ró¿nych wartoœci, co sugeruje, ¿e mo¿e reprezentowaæ "obecny stan pogody" (ikonê), obliczany przez czujnik lub, co jest bardziej prawdopodobne, dostarczany przez pogodowe API. Zdroworozs¹dkowo nas³onecznienie powinno pe³niæ kluczow¹ rolê przy generowaniu energii przez panele s³oneczne, zatem podwojenie obserwacji w tym przypadku zdaje siê byæ ca³kowicie uzasadnione; umo¿liwa to wyeliminowanie potencjalnych b³êdnych pomiarów.

### Po³o¿enie s³oñca

```{r sun_data}
lapply(solar_data[, c('altitude', 'azimuth', 'dist')], summary)
```
 *Azimuth* to azymut, czyli  k¹t zawarty miêdzy pó³nocn¹ czêœci¹ po³udnika odniesienia a danym kierunkiem poziomym. Zmienna *altitude* opisuje wysokoœæ, prawdopodobnie s³oñca nad horyzontem, poniewa¿ jej wartoœci rosn¹ do godzin po³udniowych, a nastêpnie malej¹. Zmienna *dist* jest taka sama dla wszystkich czujników oraz zmienia siê ka¿dego dnia. Przygl¹daj¹c siê wykresowi zale¿noœci jej wartoœci od *day*(czyli dnia roku) ³atwo zauwa¿yæ jej cyklicznoœæ. Prawdopodobnie okreœla ona odleg³oœæ Ziemi od S³oñca w danym dniu. Ta grupa atrybutów pozwala okreœliæ po³o¿enie s³oñca wzglêdem czujnika.

```{r plot_1}
ggplot() + geom_line(data = solar_data, aes(x = day, y = dist)) + labs(title="Zmiana atrybutu dist w dniach roku")
```

### PCNM
```{r pcnm_data}
lapply(solar_data[, 33:47], summary)
```
Atrybuty PCNM (z angielksiego Principal coordinates of neighbour matrices) to najprawdopodobniej zmienne pozwalaj¹ce opisaæ dok³adniej po³o¿enie ka¿dego czujnika wzglêdem innych czujnikóW. Pozwalaj¹ na bardziej wnikliw¹ analizê po³o¿enia dla ka¿dego z czujników poprzez stworzenie w³asnej macierzy s¹siedztwa dla ka¿dego z nich. Wartoœci tych parametrów s¹ sta³e dla *idsito*.

### Atrybuty *I
```{r}
lapply(solar_data[, c(20:26, 30:32, 49)], summary)
```
Atrybuty pogodowe z *i* na koñcu zapewne s¹ wynikiem transformacji wartoœci tych samych atrybutów bez litery *i*. Wydaje siê byæ prawdopodobne, ¿e do obliczenia ich wartoœci pos³u¿y³, wspomniany w poprzedniej grupie atrybutów, aglorytm radz¹cy sobie z problemem autokorelacji przestrzennej, wynikaj¹cej z bliskiego po³o¿enia czujnikóW.

### Energia
```{r energy_data}
lapply(solar_data["kwh"], summary)
```
Ostatni analizowany atrybut to znormalizowana do przedzia³u <0:1> wartoœæ wytworzonej energii przez dany czujnik w danym dniu o danej godzinie. Wartoœæ tej zmiennej ma docelowo zostaæ "przewidziana" na podstawie wartoœci pozosta³ych parametrów.

## Przetwarzanie brakuj¹cych danych
W samym zbiorze problem "brakuj¹cych danych" nie wystêpuje - wszêdzie jakieœ dane liczbowe s¹, natomiast po analizie wykresu w póŸniejszym rozdziale mo¿na zauwa¿yæ problem awarii czujnika. W tym przypadku nale¿y brakuj¹ce obserwacje (produkcja energii na poziomie 0) zast¹piæ innymi, wiarygodnymi.
z wykresu -> awaria czujnika, co zrobiæ ?! - mo¿e dane z poprzedniego roku dla tego miesi¹ca? 
gdy kwh==0 i irri>0 -> nie ma energii, a by³o s³oñce
gdy irri==0 i kwh>0 -> energia wyprodukowana, a s³oñca ni ma
```{r data_repair}
solar_data_repaired <- solard_data #tutaj bêd¹ najró¿niejsze poprawki
```


## Korelacja atrybutów
Stworzono macierz korelacji pomiêdzy (prawie)wszystkimi atrybutami (bez atrybutów: "data" oraz "idsito")
```{r corr_matrix, fig.width=10, fig.height=10}
#cor <- rcorr(as.matrix(solar_data[, !names(solar_data) %in% c("data", "idsito")]))
corr_matrix <- cor(as.matrix(solar_data[, !names(solar_data) %in% c("data", "idsito")]), method = "spearman")
corrplot(as.matrix(corr_matrix), order = "FPC", type="lower", tl.col = "black", tl.srt = 45)
```
Analizuj¹c powy¿sz¹ macierz pod k¹tem korelacji atrybutu *kwh* z pozosta³ymiy atrybutami mo¿na ³atwo zauwa¿yæ siln¹ odwrotn¹ korelacjê z wartoœci¹ *humidity*(wilgotnoœæ) co jest logiczne, poniewa¿ opad deszczu skutecznie zmniejsza iloœæ wytwarzanej energii przez panel s³oneczny. Atrybut *kwh* jest skorelowany silnie z wartoœci¹ *irri*, czyli nas³onecznienia oraz s³abo z atrybutami opisuj¹cymi temperaturê.

Mo¿na tak¿e zauwa¿yæ na niektórych atrybutach s³ab¹ odwrotn¹ korelacjê pomiêdzy parami atrybut-atrybuti. (byæ mo¿e i jak invert?)


## Interaktywny wykres
```{r interactive_plot, fig.width=9, fig.height=7, fig.align='center'}
solar_data_monthYear <-  solar_data %>% mutate(month_year = format(as.POSIXct(data), "%Y/%m")) %>% group_by(idsito, month_year) %>% summarise(sum_of_kwh = sum(kwh))
plot <- ggplot() + geom_line(data=solar_data_monthYear, aes(x=month_year, y=sum_of_kwh, group=idsito, color=factor(x = 1*idsito, labels=c(1:17)))) + labs(color="Legenda") + labs(title="Miesiêczna produkcja energi dla czujników", x="year_month") +
theme(axis.text.x=element_text(angle=90, vjust=0.5), axis.title.x = element_text(vjust=2.5))
ggplotly(plot)
```
Powy¿szy interaktywny wykres pozwala porównaæ sumê wyprodukowanej energii przez czujniki w ka¿dym miesi¹cu. 

Analizuj¹c wykres mo¿na dojœæ do nastêpuj¹cych wniosków:
* czujniki ulegaj¹ awariom; potencjalne awarie wystêpuj¹ w miejscach drastycznego spadku produkowanej energii do 0 (np. czujnik 16 w sierpniu 2013r., ),
* krzywa miesiêcznej sumy produkowanej energii dla ka¿dego czujnika ma podobny kszta³t,
* czujnik 10 zdecydowanie lepiej prosperowa³ w ostatnim kwartale 2012 w porównaniu do reszty. 

## Próba stworzenia regresora
```{r regessor_creation}
#test/learning data 
#use some regression algorithms
#RMSE 
```
Sekcja próbuj¹ca stworzyæ regresor
Usuniêcie pomiarów czujnika 10.

## Analiza modelu regresji
```{r regressor_rating}
#find best + analyze
```
Jaki model i czy ma sens.
